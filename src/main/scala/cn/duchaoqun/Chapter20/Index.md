## Chapter 20 Actor

- Actor 是扩展 Actor trait 的类
- 这个类的对象就是一个线程，receive 方法不断地循环等待发送过来的消息，然后进行处理。
- 发送到这个 Actor 的消息被存储到一个 “邮箱” 里面，receive 函数从邮箱中取出消息传递给自己的参数。
- receive 方法的参数是一个偏函数，这个代码块被转换成一个类型为 PartialFunction[Any, T] 的对象。
- 其中类型 T 是 => 右面的表达式的结果类型。

- 注意：消息传递的过程是异步的，你不会知道它会以什么样的顺序到达，在设计的时候应该考虑到不要依赖消息的投递顺序。
- 注意：如果 receive 方法没有收到消息，这个线程就会被阻塞，直到有可以匹配的消息传递过来。
- 注意：“邮箱”可能会被无法匹配的消息占满，必要的时候需要添加 case _ => 来处理无效消息。
- 注意：不要再不同的 Actor 中使用共享的对象。

## 【Demo01】创建和启动 Actor

## 【Demo02】发送消息到 Actor

## 【Demo03】取出 Actor 收到的消息

## 【Demo04】向其他 Actor 发送消息

- 当计算被拆分成不同的部分，分别在不同的 Actor 中执行的时候，每个部分的计算结果需要收集到一起。
- Actor 可以将结果存放到一个线程安全的数据结构中，比如一个并发的 HashMap，但是 Actor 模型并不鼓励使用共享数据。
- 所以当 Actor 结果计算完成后，需要向其他 Actor 发送消息。
- 一个 Actor 是如何知道应该向哪里发送计算结果呢？ 这里有几个设计选择：
- 1. 可以有一些全局的 Actor ，但是当 Actor 数量非常多的时候，这个方案的伸缩性并不好。
- 2. Actor 可以构造成带有指向一个或者多个 Actor 的引用。
- 3. Actor 可以接收带有指向另一个 Actor 引用的消息，在请求中提供一个 Actor 引用是一个很常见的做法。
     actor ! Compute(data, otherActorRef)
     这里的 otherActorRef 是另外一个 Actor 的引用，当计算完成的时候，应该调用这个 Actor。
- 4. Actor 可以返回消息给发送方，receive 方法会把 sender 字段设为当前消息的发送方。

- 注意：当一个 Actor 持有另外一个 Actor 的引用时，它应该只用这个引用发送消息，不能用来调用其方法。
-       如果这样做了，就违背了Actor模型的意义，它同时还可能引发争用问题（Actor 被设计出来要避免的问题）。


# 2.13.0 版本需要重新学习

## 【Demo05】消息通道【TODO】310页
## 【Demo06】同步消息和Future【TODO】311页
## 【Demo07】共享线程
## 【Demo08】Actor 的生命周期
## 【Demo09】将多个 Actor 链接到一起
## 【Demo10】Actor 的设计。