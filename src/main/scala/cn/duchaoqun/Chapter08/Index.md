## Chapter 08 extends

- 实现代码复用，通用代码使用父类来做，如果需要修改的话，只需要修改父类就可以了，子类无需变化。
- extents final 关键字和Java一样。
- 只有主构造器可以调用父类的主构造器。
- 我们可以重写属性字段。
- 父类一般都是抽象的。
- 父类的方法，大部分子类都可以直接使用，部分会有权限的问题。
- 类继承的时候，会不会继承它的伴生对象？不会的。
- 抽象方法必须实现其代码，实现方法或者复写方法必须使用override关键字，方便自己，方便他人。
- 调用父类方法直接使用super既可！
- 父类型的对象，如何转换成子类型的对象？

### 【Demo01】扩展类

- 被 final 关键字修饰的类不能被继承。
- 被 final 关键字修饰的属性不能被重写。
- 重写方法的时候必须使用 override。

### 【Demo02】重写方法

- 在 Scala 中重写一个非抽象的方法必须使用 override 关键字。
- 调用父类的方法和 Java 一样，使用 super 关键字。

### 【Demo03】类型检查和转换

- 要测试某个对象是否属于某个类，可以使用 isInstanceOf 方法，如果检验成功，就可以使用 asInstanceOf 转换成该类的引用。
- 与类型检查和转换相比，模式匹配是更好的选择。

### 【Demo04】受保护的字段和方法

- 与 Java C++ 一样，可以将字段或者方法声明为 protected，这样的成员可以被任何子类访问，但不能从其他位置访问到。

### 【Demo05】父类的构造

- 一个类有一个主构造器，和任意多个辅助构造器，而每个辅助构造器必须以调用主构造器开始。
- 这样带来的后果是辅助构造器永远也不能调用父类的构造器。
- 子类的辅助构造器最终都会调用子类的主构造器，只有主构造器可以调用父类的构造器。

### 【Demo06】重写字段

- def 关键字只能重写另外一个 def
- val 能重写另一个 val 或者不带参数的 def
- var 只能重写另外一个 abstract var

### 【Demo07】匿名子类

- 你可以通过包含带有定义或者重写的代码块的方式创建一个匿名的子类。

### 【Demo08】抽象类

- 和 Java 一样，使用 abstract 关键字来定义抽象类，标记这个类不能被实例化，通常是因为它的某个或者几个方法没有定义完整。

### 【Demo09】抽象字段

- 抽象字段，就是没有初始化值的字段。
- 具体的子类必须提供具体的字段。

### 【Demo10】构造顺序和提前定义

### 【Demo11】类的继承层级

- Any 是整个继承层级的根节点，提供isInstanceOf、asInstanceOf方法。
- Any 有两个子类型 AnyVal 和 AnyRef。
- AnyVal 值类型标记，基本类型都是它的子类 Boolean、Byte、Char、Int、Long、Float、Double、Short、Unit
- AnyRef 引用类型，该类追加了来自 Object 类的监视方法 wait 和 notify/notifyAll，同时提供了一个带参数的方法 synchronized。（远离这个内容，使用更高层次的并发结构）

### 【Demo12】对象相等性

- 在 Scala 中， AnyRef 的 eq 方法检查两个引用是否指向同一个对象，AnyRef 的 equals 方法调用eq。
- 当你实现类的时候，应该考虑重新实现 equals 方法，提供一个与实际需求相匹配的相等性判断方法。