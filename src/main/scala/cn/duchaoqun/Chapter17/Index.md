## Chapter 17 类型参数

- 在 Java 中 List<String>和 List<Int> 类型是不一样的，但是 jvm 在编译时会进行"泛型擦除"。
- 导致 List<String> 和 List<Int> 都是 Class<List> 为了得到正确的类型，需要通过反射。
- Java 中的泛型基本上都是在编译器这个层次来实现的，在生成的 Java 字节码中是不包含泛型中的类型信息的。
- 使用“泛型”的时候加上的类型参数，会在编译器编译代码的时候去掉，这个过程就称为类型擦除。
- 泛型擦除是为了兼容 jdk1.5 之前的 jvm，在这之前是不支持泛型的。

- 用于指定类可以接受任意类型参数。参数的类型在实际使用时才被确定，泛型可以有效的增强程序的适应性，使用泛型可以使得类或者方法具有更强的通用性。
- 1. 定义类的时候，在类的名字后面添加"类型参数"([A,B]) 表明对这个类的参数(主构造函数传递过来的对象类型)进行限定(界定)。
- 2. 例如 Animals 类的类型参数为 [A,B] 限定参数的类型为 A 和 B 类型。这个类的构造过程需要传递两个对象，一个 A 类型，一个 B 类型。
- 3. 对于A 和 B 到底是什么类型需要在执行的时候才才能确定。
- 4. 在实际运行的时候会擦出这个类型参数，仅在编译的时候有效。

### 【Demo01】泛型类【使用类型参数(Type parameter)的类】

- 在 Scala 中，你可以用类型参数来定义类和函数，这样的类和函数可以用于多种类型。

### 【Demo02】泛型函数【使用类型参数(Type parameter)的函数和方法】

### 【Demo03】类型参数的上下界定

### 【Demo04】视图界定【View bounds】2.12.0 以后过期

- 可以认为是【类型参数】的上下界定的加强版。
- View Bounds视图界定，可以进行某种神秘的转换，把你的类型可以在没有直觉的情况下，转换成为目标类型。
- 例如在 SparkContext 这个核心类中，有 T <% Writable 方式的代码，这个代码所表达的是 T 必须是 Writable 类型的。
- 但是 T 没有直接继承自 Writable 接口，此时就需要通过"implicit"的方式来实现这个功能。
- 2.12.0 过期

### 【Demo05】上下文界定

### 【Demo06】Manifest 上下文界定

### 【Demo07】多重界定

- 类型变量可以同时拥有上界和下界:  T >: Lower <: Upper
- 你不能同时拥有多个上界或者多个下界，不过，你依然可以要求一个类型实现多个特质。
  T <: Comparable[T] with Serializable with Cloneable
- 你可以有多个视图界定： T <% Comparable[T] <% String // TODO
- 你也可以有多个上下文界定： T: Ordering: Manifest

### 【Demo08】类型约束

### 【Demo09】协变

### 【Demo10】逆变

### 【Demo11】协变和逆变点

- 看 demo10 最后的函数，在参数上市逆变的，在返回值上市协变的。
- 通常而言对于某个对象消费的值适用逆变，而对于它产出的值则适用协变。
- 如果一个对象同时消费和产出某个值，则类型应该保持不变。这通常适用于可变数据结构。
- Scala 中数组是不支持型变的，你不能将一个 Array[Student] 转换成 Array[Person]，或者是反过来。这样不安全。
- // TODO ，还需要深入理解。

### 【Demo12】对象不能泛型

- // TODO，还需要深入理解。

### 【Demo13】类型通配符
