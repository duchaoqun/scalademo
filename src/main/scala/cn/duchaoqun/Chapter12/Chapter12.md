# Chapter 12 Function

  * 背景：整个 IT 编程技术的发展史，其实就是一部封装史
  * 1. Function 时代：C 语言中提供了函数的概念，把若干条语句进行封装和复用。
  * 2. Class 时代：C(java)等语言提供类的对象，把数据和处理数据业务的逻辑封装起来。
  * 3. 框架时代：最大的封装就是使用框架！把数据，代码和驱动封装起来。

## 创建函数

- 【Demo01】使用 def 关键字来定义 function。

## 无参函数

- 【Demo02】使用 def 关键字来定义，需要声明结果类型。

## 有参函数

- 【Demo02】斐波那契数列
- 【Demo04】使用默认参数的函数
- 【Demo06】可变长的参数
- 【Demo07】使用“函数作为参数”的函数
- 【Demo10】参数“类型”推断

## 函数的结果类型

- 【Demo05】如果函数名称和函数体之间没有等号，那么该函数的返回值类型会推断失败(不是函数体最后一条语句的结果类型)，
  这个函数的结果类型是Unit。

## 将函数赋值给 val 变量

- 【Demo08】高级应用，将函数赋值给变量。

## 匿名函数

- 【Demo09】使用匿名函数

## 常用的高阶函数

- 【Demo11】

## 闭包

- 【Demo12】

## 柯里化【TODO】

- 【Demo13】


## TODO


- SAM转换【快学Scala 书中12.7】

- 控制抽象【TODO】
- return 表达式【TODO】

/**
  * 12.1 将函数赋值给变量
  * *
  * * 1. 函数可以简单的包裹一条或者几条语句,该代码接受若干参数,经过代码处理后返回结果.型如数学中的 F(x)=x + 1
  * * 2. 在scala中,函数是一等公民,可以像变量一样被传递,被赋值,同时函数可以赋值给变量.变量也可以赋值给函数.之所以会这样,原因是因为函数背后是一个对象,也就是说这个函数其实是一个变量(是Scala帮助我们自动生成的)
  * * 可以天然的被序列化和反序列化,
  * * 意义: 可以天然的序列化和反序列化的直接好处就是函数可以在分布式系统上传递.
  * * 意义: 因为函数背后其实是类和对象,所以可以和普通的的变量完全一样的运用在普通变量可以运用的地方,包括作为参数传递,作为返回值被变量赋值,和赋值给变量.
  * *
  * * 关于函数入门的几个特点:
  * *
  * * 2. 函数会自动进行类型推断,来推断函数的返回值类型.注意：必须给出所有参数的类型,如果函数体不是递归的,那么我们不需要定义返回值类型,编译器会自动推断
  * * 3. 如果函数名称和函数体之间没有等号,那么该函数的返回值类型会推断失败(不是函数体最后一条语句的结果类型),这个函数的结果类型是Unit. 见如下A-B案例.
  * * 4. 如果在函数体中,无法推倒出具体的结果类型,则必须声明结果类型.例如案例C
  * * 5. 函数的参数可以有默认值,这样在调用函数的时候,如果不想改变默认值的话,这样就不传递该参数,直接使用默认值,这在变成中意义重大,这在Spark等变成中非常有用,因为框架一般有自己的默认配置和实现
  * * ,这时就非常好的使用默认值了.
  * * 6. 我们可以基于函数的参数的名称,来调整函数的传递参数的顺序.重点在于为什么可以这么做呢? 原因在于函数背后就是类! 其参数就是类的成员,所以无所谓顺序. 见如下案例E
  * * 7. 可变参数中的数据其实被收集成为Array数组.例如main的args 就是Array[String]的方式来实现的.
  * *
  * * 补充: 不依赖于类的def就是函数,依赖于类的叫做方法,没有返回值的叫做过程.
  */

- Scala 类库里面有 22 个 function 特质。 Function0

  def javaVersion1(): Unit = () => scala.sys.props("java.version") //如返回Unit则需要参数,仅使用方法的副作用处理输入对象
  def javaVersion2 = () => scala.sys.props("java.version") //不需要参数,定义的是方法?
  def test1(): Unit = {
    scala.sys.props("java.version")
  }
  
  // 省略的函数体花括号
  def matchTestA(x: Any): Any = {
    x match {
      case 1 => "one"
      case _ => "many"
    }
  }
  def matchTestB(x: Any): Any = x match {
    case 1 => "one"
    case _ => "many"
  }