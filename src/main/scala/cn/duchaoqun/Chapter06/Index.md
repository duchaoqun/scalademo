## Chapter 06 object【单例对象与伴生对象】

### 【Demo01】单例对象（singleton object）

- Java 中你通常会用到既有实例又有静态方法的类。
- Scala 中没有静态方法或者静态字段，你可以使用单例对象来实现。
- 单例对象作为存放工具函数和常量的地方。
- 通常可以高效的共享单个不可变实例。
- 单例对象本质上可以拥有类的所有特性，它甚至可以扩展类或特质，只有一个例外，它不能提供构造器参数，不能使用 new 实例化。
- 通常在半生对象里面定义隐式转换的内容。
- 你可以通过扩展Enumeration对象来实现枚举。
- 在 API 设计的时候，如果将要过期的方法，可以将会变动的内容放到 object 里面，方便版本的迭代。

## 【Demo02】伴生对象/类（companion object/class）

- 定义一个class，然后再定义一个同名的object，这个 class 就是 object 伴生类，同名的 object 就是 class 的伴生对象(存放静态方法，隐式转换等内容)。
- 类和伴生对象可以相互访问私有特性，它们必须在一个源文件中。
- 伴生的 object 中的内容都是 class 的静态内容，也就是说 Object 中的内容，class 都可以在没有实例的时候直接调用。
- 伴生对象的 apply 方法通常用来构造伴生类的新实例。

## 【Demo03】扩展类或特质的对象

## 【Demo04】对象中的 apply 方法

- 正是因为可以在没有类的实例对象的时候，可以直接调用 object 中的一切，所以可是使用 object 中的特定方法来创建实例。
  这个特定方法就是 apply(object 中的 apply 方法是 class 对象生成的工厂方法，用来控制对象的生成)。
- apply 具有类的对象生成的一切的生杀大权，抽象类不可以直接实例化，在 apply 方法中可以实例化抽象类的子类，以 Spark 中的图计算为例。
- 可以在 object 中构造很多 apply 方法，多种实例化对象的方法。

## 【Demo05】应用程序入口（main方法）

- 使用 object 关键字定义类并创建main入口方法，或者继承 App 特质来创建程序入口。
- 如果不想显示定义 main 方法，可以用扩展 App 特质的对象。

## 【Demo06】枚举 // TODO