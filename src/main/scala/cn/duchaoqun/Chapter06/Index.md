## Chapter 06 object【单例对象与伴生对象】

### 【Demo01】单例对象（singleton object）

- Java 中你通常会用到既有实例又有静态方法的类。
- Scala 中没有静态方法或者静态字段，你可以使用单例对象来实现。
- 单例对象作为存放工具函数和常量的地方。
- 通常可以高效的共享单个不可变实例。
- 单例对象本质上可以拥有类的所有特性，它甚至可以扩展类或特质，只有一个例外，它不能提供构造器参数，不能使用 new 实例化。
- 通常在半生对象里面定义隐式转换的内容。
- 你可以通过扩展Enumeration对象来实现枚举。
- 在 API 设计的时候，如果将要过期的方法，可以将会变动的内容放到 object 里面，方便版本的迭代。

## 【Demo02】伴生对象/类（companion object/class）

- 定义一个class，然后再定义一个同名的object，这个 class 就是 object 伴生类，同名的 object 就是 class 的伴生对象(存放静态方法，隐式转换等内容)。
- 类和伴生对象可以相互访问私有特性，它们必须在一个源文件中。
- 伴生的 object 中的内容都是 class 的静态内容，也就是说 Object 中的内容，class 都可以在没有实例的时候直接调用。
- 伴生对象的 apply 方法通常用来构造伴生类的新实例。

## 【Demo03】扩展类或特质的对象

- 一个 Object 可以扩展类以及一个或者多个特质，其结果是扩展了指定类以及特质的类的对象，同时拥有在对象定义中给出的所有特性。
- 场景：给出可以被共享的默认对象。

## 【Demo04】对象中的 apply 方法

- 正是因为可以在没有类的实例对象的时候，可以直接调用 object 中的一切，所以可是使用 object 中的特定方法来创建实例。
  这个特定方法就是 apply(object 中的 apply 方法是 class 对象生成的工厂方法，用来控制对象的生成)。
- apply 具有类的对象生成的一切的生杀大权，抽象类不可以直接实例化，在 apply 方法中可以实例化抽象类的子类，以 Spark 中的图计算为例。
- 可以在 object 中构造很多 apply 方法，多种实例化对象的方法。

## 【Demo05】应用程序入口（main方法）

- 每个 Scala 程序必须从一个对象的 main 方法开始。
- 使用 object 关键字定义类并创建main入口方法，或者继承 App 特质来创建程序入口（早期的叫Application特质）。
- 如果不想显示定义 main 方法，可以用扩展 App 特质的对象。
- main 方法的类型是 Array[String] -> Unit(仅带一个参数 Array[String]，且返回类型为 Unit 的单例对象)
- 这里的 main 是方法，因为他不具备函数特征。
- 按照目前 OS 的原理，main 方法都是运行在主线程中的。
- OS 的运行分为 Kernel Space 和 User Space，应用程序是运行在 UserSpace 中的，Scala 所在的进程一般都是透过OS Fork出来的，
- 被 Fork 出来的应用程序进程默认会有主线程，而我们的 main 方法就是默认在主线程中的。

## 【Demo06】枚举 

- 针对类的实例对象是固定的，使用枚举？为什么不使用单例对象？
// TODO